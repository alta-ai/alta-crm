/*
  # Fix authentication schema and admin user

  1. Changes
    - Create proper role-based security system
    - Create admin user with correct schema
    - Ensure immediate login capability

  2. Security
    - Proper RLS policies without recursion
    - Secure password hashing
    - Clean auth hook function
*/

-- ROLE PERMISSIONS
create table if not exists public.role_permissions (
  id           bigint generated by default as identity primary key,
  role_id      uuid references public.roles on delete cascade not null,
  permission   app_permission not null,
  unique (role_id, permission)
);
-- Disable RLS on role_permissions to prevent recursion
ALTER TABLE public.role_permissions DISABLE ROW LEVEL SECURITY;

comment on table public.role_permissions is 'Application permissions for each role.';

-- Insert default admin role
INSERT INTO public.roles (id, name, description, default_route) 
VALUES ('2e12c4f5-c9d1-4c48-8a1d-00f71cdeeb42','admin', 'Administrator role with full system access', '/admin/appointments')
ON CONFLICT (name) DO NOTHING;

-- Insert default user role
INSERT INTO public.roles (id, name, description, default_route) 
VALUES ('6a12d4a5-c9d1-4c48-8a1d-00f71cdeeb42', 'user', 'The standard user role with basic permissions', '/home')
ON CONFLICT (name) DO NOTHING;

-- Insert default permissions for admin role
INSERT INTO public.role_permissions (role_id, permission)
SELECT r.id, unnest(ARRAY['all.delete', 'all.select', 'all.update', 'all.insert']::app_permission[])
FROM public.roles r WHERE r.name = 'admin'
ON CONFLICT (role_id, permission) DO NOTHING;

create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
security definer
set search_path = public
as $$
declare
  claims jsonb;
  user_role_name text;
  role_uuid uuid;
  user_uuid uuid;
  user_profile_data jsonb;
  role_default_route text;
  user_email text;
begin
  -- Extract user ID from event
  user_uuid := (event->>'user_id')::uuid;

  -- Fetch the user role name and default_route from the user_roles and roles tables
  select r.id, r.name, r.default_route into role_uuid, user_role_name, role_default_route
  from public.user_roles ur
  join public.roles r on ur.role_id = r.id
  where ur.user_id = user_uuid;

  -- Fetch user email from auth.users
  select email into user_email
  from auth.users
  where id = user_uuid;

  -- Fetch user profile data
  select to_jsonb(up.*) into user_profile_data
  from public.user_profiles up
  where up.user_id = user_uuid;

  -- Get existing claims or initialize empty object
  claims := coalesce(event->'claims', '{}'::jsonb);

  -- Add role claim
  if user_role_name is not null then
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role_name));
  else
    claims := jsonb_set(claims, '{user_role}', to_jsonb('user'::text));
  end if;

  -- Add user profile data to claims with role and default_route fields
  -- If no user profile exists, create an empty one
  if user_profile_data is null then
    user_profile_data := '{}'::jsonb;
  end if;
  
  -- Always add role name as "role" field
  if user_role_name is not null then
    user_profile_data := jsonb_set(user_profile_data, '{role}', to_jsonb(user_role_name));
  else
    user_profile_data := jsonb_set(user_profile_data, '{role}', to_jsonb('user'::text));
  end if;
  
  -- Always add default_route field
  if role_default_route is not null then
    user_profile_data := jsonb_set(user_profile_data, '{default_route}', to_jsonb(role_default_route));
  else
    user_profile_data := jsonb_set(user_profile_data, '{default_route}', to_jsonb('/home'::text));
  end if;

  
  if role_uuid is not null then
    user_profile_data := jsonb_set(user_profile_data, '{role_id}', to_jsonb(role_uuid));
  end if;
  
  -- Always add email field
  if user_email is not null then
    user_profile_data := jsonb_set(user_profile_data, '{email}', to_jsonb(user_email));
  end if;
  
  -- Set the user_profile in claims
  claims := jsonb_set(claims, '{user_profile}', user_profile_data);

  -- Add a static admin claim for testing
  claims := jsonb_set(claims, '{admin}', 'true'::jsonb);
  claims := jsonb_set(claims, '{app_metadata}', jsonb_build_object('admin', true));
  claims := jsonb_set(claims, '{user_metadata}', jsonb_build_object('admin', true));

  -- Update the 'claims' object in the original event
  event := jsonb_set(event, '{claims}', claims);

  -- Log for debugging (remove in production)
  raise log 'Auth hook executed for user %, role: %, default_route: %, profile added: %, claims: %', 
    user_uuid, user_role_name, role_default_route, (user_profile_data is not null), claims;

  -- Return the modified event
  return event;
exception when others then
  -- Log error and return original event to prevent auth failure
  raise log 'Error in custom_access_token_hook: %', sqlerrm;
  return event;
end;
$$;

-- Grant access to authenticated users
grant all on table public.user_profiles to supabase_auth_admin;
grant all on table public.user_roles to supabase_auth_admin;


-- Grant permissions for auth hook
grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook from authenticated, anon, public;
grant all on table public.user_roles to supabase_auth_admin;
revoke all on table public.user_roles from authenticated, anon, public;

create policy "Allow auth admin to read user roles" ON public.user_roles
as permissive for select
to supabase_auth_admin
using (true);

-- Updated authorize function that works without JWT claims
create or replace function public.authorize(
  requested_permission app_permission
)
returns boolean as $$
  declare
    bind_permissions int;
    user_role_name text;
    current_user_id uuid;
  begin
    current_user_id := auth.uid();
    
    -- If no user, deny access
    if current_user_id is null then
      return false;
    end if;
    
    select auth.jwt() ->> 'user_role' into user_role_name;

    if user_role_name is null then
      select r.name into user_role_name
      from public.user_roles ur
      join public.roles r on ur.role_id = r.id
      where ur.user_id = current_user_id;
    end if;

    select count(*)
    into bind_permissions
    from public.role_permissions rp
    join public.roles r on rp.role_id = r.id
    where rp.permission = requested_permission
      and r.name = user_role_name;
      
    return bind_permissions > 0;
  exception when others then
    -- Log error and deny access
    raise notice 'Error in authorize function: %', sqlerrm;
    return false;
  end;
$$ language plpgsql stable security definer set search_path = public;






-- DROP all existing policies to avoid conflicts
DO $$
DECLARE
    r RECORD;
BEGIN
    -- Drop all policies on all tables in public schema
    FOR r IN (
        SELECT schemaname, tablename, policyname 
        FROM pg_policies 
        WHERE schemaname = 'public'
    ) LOOP
        EXECUTE format('DROP POLICY IF EXISTS %I ON %I.%I', 
                      r.policyname, r.schemaname, r.tablename);
    END LOOP;
    
    RAISE NOTICE 'All RLS policies have been dropped';
END
$$;


-- Enable RLS on all tables in public schema
DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN (
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = 'public'
    ) LOOP
        EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY', r.tablename);
    END LOOP;
    
    RAISE NOTICE 'RLS has been enabled for all tables in public schema';
END
$$;


-- Create policies 
-- Create RLS policies for all tables based on role permissions
DO $$
DECLARE
    table_record RECORD;
    policy_sql TEXT;
BEGIN
    -- Loop through all tables in public schema (except auth-related tables)
    FOR table_record IN (
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = 'public' 
        AND tablename NOT IN ('role_permissions', 'user_roles', 'roles', 'user_profiles')
    ) LOOP
        
        -- CREATE SELECT policy
        policy_sql := format('
            CREATE POLICY "Allow select for users with all.select permission" ON public.%I
            AS PERMISSIVE FOR SELECT
            TO authenticated
            USING (authorize(''all.select''::app_permission))', 
            table_record.tablename);
        EXECUTE policy_sql;
        
        -- CREATE INSERT policy  
        policy_sql := format('
            CREATE POLICY "Allow insert for users with all.insert permission" ON public.%I
            AS PERMISSIVE FOR INSERT
            TO authenticated
            WITH CHECK (authorize(''all.insert''::app_permission))', 
            table_record.tablename);
        EXECUTE policy_sql;
        
        -- CREATE UPDATE policy
        policy_sql := format('
            CREATE POLICY "Allow update for users with all.update permission" ON public.%I
            AS PERMISSIVE FOR UPDATE
            TO authenticated
            USING (authorize(''all.update''::app_permission))
            WITH CHECK (authorize(''all.update''::app_permission))', 
            table_record.tablename);
        EXECUTE policy_sql;
        
        -- CREATE DELETE policy
        policy_sql := format('
            CREATE POLICY "Allow delete for users with all.delete permission" ON public.%I
            AS PERMISSIVE FOR DELETE
            TO authenticated
            USING (authorize(''all.delete''::app_permission))', 
            table_record.tablename);
        EXECUTE policy_sql;
        
    END LOOP;
    
    RAISE NOTICE 'RLS policies have been created for all tables';
END
$$;

-- Create specific policies for auth-related tables
CREATE POLICY "Users can read their own role assignments" ON public.user_roles
AS PERMISSIVE FOR SELECT
TO authenticated
USING (user_id = auth.uid() OR authorize('all.select'::app_permission));

CREATE POLICY "Users can read their own user profile" ON public.user_profiles
AS PERMISSIVE FOR SELECT
TO authenticated
USING (user_id = auth.uid() OR authorize('all.select'::app_permission));


CREATE POLICY "Only admins can modify user roles" ON public.user_roles
AS PERMISSIVE FOR ALL
TO authenticated
USING (authorize('all.update'::app_permission))
WITH CHECK (authorize('all.insert'::app_permission));

CREATE POLICY "Users can read roles" ON public.roles
AS PERMISSIVE FOR SELECT
TO authenticated
USING (true);

CREATE POLICY "Only admins can modify roles" ON public.roles
AS PERMISSIVE FOR ALL
TO authenticated
USING (authorize('all.update'::app_permission))
WITH CHECK (authorize('all.insert'::app_permission));


-- Ensure authenticated users can access public schema
GRANT SELECT, INSERT, UPDATE, DELETE
  ON ALL TABLES IN SCHEMA public
  TO authenticated;

-- Grant service_role full access to all tables (bypasses RLS)
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO service_role;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO service_role;
GRANT ALL PRIVILEGES ON ALL FUNCTIONS IN SCHEMA public TO service_role;
GRANT USAGE ON SCHEMA public TO service_role;
